<!DOCTYPE HTML>
<html>

<head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="viewport" content="width=device-width">
    <title>Webshim</title>
    <link href="css/styles.css" rel="stylesheet" />

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script>
        // set options for html5shiv
        if (!window.html5) {
            window.html5 = {};
        }
        window.html5.shivMethods = false;
    </script>
    <script src="js-webshim/minified/extras/modernizr-custom.js"></script>

    <script src="js-webshim/minified/polyfiller.js"></script>
    <script src="demo-js/demo.js"></script>
    <script>
        $.webshims.polyfill(); // load all available polyfills
    </script>

</head>

<body>

    <div id="sidebar" class="interface">

        <a class="toc_title" href="#">
            Webshim <span class="version">(1.11.1)</span>
        </a>
        <ul class="toc_section">
            <li>&raquo; <a href="https://github.com/aFarkas/webshim">GitHub Repository</a></li>
        </ul>

        <a class="toc_title" href="#introduction"> Introduction </a>

         <a class="toc_title" href="#Guide-installation"> Guide </a>
        <ul class="toc_section">
            <li>– <a href="#Guide-installation">Installation</a>
            </li>
            <li>– <a href="#Guide-configuration">Configuration</a>
            </li>
            <li>- <a href="#Guide-fire-when-ready">Fire When Ready</a>
            </li>
            <li>- <a href="#Guide-dom-abstractions">DOM Abstractions</a>
            </li>
        </ul>

        <a class="toc_title" href="#Customizing"> Customizing </a>
        <ul class="toc_section">
            <li>- <a href="#Customizing-modernizr">Modernizr</a>
            </li>
            <li>- <a href="#Customizing-extending">Writing a New Polyfill</a>
            </li>
        </ul>


        <!--
    <a class="toc_title" href="#Events">
      shiv and innerShiv
    </a>
    <ul class="toc_section">
      <li>– <a href="#Events-on">on</a></li>
    </ul>

    <a class="toc_title" href="#Events">
      ES5/JavaScript 1.8.5
    </a>
    <ul class="toc_section">
      <li>– <a href="#Events-on">on</a></li>
    </ul>

    <a class="toc_title" href="#Events">
      Form Validation
    </a>
    <ul class="toc_section">
      <li>– <a href="#Events-on">on</a></li>
    </ul>

    <a class="toc_title" href="#Events">
      Canvas
    </a>
    <ul class="toc_section">
      <li>– <a href="#Events-on">on</a></li>
      <li>– <a href="#Events-listenToOnce">listenToOnce</a></li>
      <li>- <a href="#Events-catalog"><b>Catalog of Built-in Events</b></a></li>
    </ul>

    <a class="toc_title" href="#Events">
      &lt;audio&gt;, &lt;video&gt;, and &lt;track&gt;
    </a>
    <ul class="toc_section">
      <li>– <a href="#Events-on">on</a></li>
    </ul>

    <a class="toc_title" href="#Events">
      JSON, localStorage, and sessionStorage
    </a>
    <ul class="toc_section">
      <li>– <a href="#Events-on">on</a></li>
    </ul>

    <a class="toc_title" href="#Events">
      geolocation
    </a>
    <ul class="toc_section">
      <li>– <a href="#Events-on">on</a></li>
    </ul>

    <a class="toc_title" href="#Events">
      &lt;details&gt; and &lt;summary&gt;
    </a>
    <ul class="toc_section">
      <li>– <a href="#Events-on">on</a></li>
    </ul>

    <a class="toc_title" href="#Events">
      FileReader
    </a>
    <ul class="toc_section">
      <li>– <a href="#Events-on">on</a></li>
    </ul>
  -->

    </div>

    <div class="container">

        <p>
            <img id="logo" src="images/webshim2.png" alt="webshim" />
        </p>

        <p>
            Webshim is a <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">polyfill</a> library that enables you to reliably use HTML5 features across browsers, even if native support is lacking.
        </p>

        <p>
            The project is <a href="https://github.com/aFarkas/webshim/">hosted on GitHub</a>, and is available for use under the <a href="http://github.com/aFarkas/webshim/blob/master/MIT-LICENSE.txt">MIT software license</a>.
        </p>

        <p>
            You can report bugs and discuss features on the
            <a href="https://github.com/aFarkas/webshim/issues">GitHub issues page</a>, or send tweets to <a href="http://twitter.com/aFarkas">@aFarkas</a>.
        </p>

        <h2 id="downloads">
      Downloads &amp; Dependencies
      <span style="padding-left: 7px; font-size:11px; font-weight: normal;" class="interface">(Right-click, and use "Save As")</span>
    </h2>

        <table>
            <tr>
                <td>
                    <a href="http://corrupt-system.de/webshims-stable.zip" class="download-button">
                        <strong><i>Version 1.11.1</i></strong>
                    </a>
                </td>
                <td class="text"></td>
            </tr>
        </table>

        <p>
            Webshim depends on <a href="http://jquery.com/">jQuery</a> and <a href="http://www.modernizr.com/">Modernizr</a>.
        </p>

        <h2 id="introduction">Introduction</h2>

        <p>
            There are many appealing HTML5 features such as form validation, geolocation, and FileReader which ease the burden of writing rich web applications.
        </p>

        <p>
            Using these features responsibly requires supporting the browsers and versions that the audience is likely to use, without breaking usability. There are two common ways to support these new features. Abstractions declare a library or piece of code that
            invents a new API which you can use to access the feature. jQuery is a good example; It defines an API that provides access to features that are buggy or incomplete, by coming up with it's own format. $.ajax is an abstraction over xmlhttprequest
            which is a standard that has varying support. The other solution is called polyfilling, which fills in the gaps in a lacking browser rather than than designing a new API.
        </p>

        <p>
            <strong>Webshim is a polyfill solution.</strong> It adds these features in a way that is transparent to the end user and developer. It enables coding against the browser standards rather than learning and maintaining abstractions. It results
            in less code that is simpler and easier to maintain.
        </p>

        <p>
            Many of the examples that follow are runnable. Click the <i>play</i> button to execute them.
        </p>


        <p id="Guide-installation">
            <b class="header">Installation</b>
            <br>Take the 'js-webshim' folder and add it to your project. (You will find a minified and a dev folder there.) Here is an example showing how to include dependencies and load webshims:
            <pre>
&lt;script src="js/jquery-1.9.1.js"&gt;&lt;/script&gt;
&lt;script src="js/modernizr-yepnope-custom.js"&gt;&lt;/script&gt;
&lt;script src="js-webshim/minified/polyfiller.js"&gt;&lt;/script&gt;
  
&lt;script&gt;
  $.webshims.polyfill();
  
  $(function(){
    // use all implemented API-features on DOM-ready
  });
&lt;/script&gt;   
</pre>
        </p>


        <p id="Guide-configuration">
            <b class="header">Configuration</b> 
            <br>The polyfill method accepts an optional whitespace-separated feature list. Call it as soon as possible (before DOM ready.)
            <pre> $.webshims.polyfill('json-storage geolocation'); </pre> 
            <strong>Available Features</strong>

            <ul style="margin: 0">
                <li style="margin-bottom: 0">json-storage</li>
                <li style="margin-bottom: 0">es5</li>
                <li style="margin-bottom: 0">geolocation</li>
                <li style="margin-bottom: 0">canvas</li>
                <li style="margin-bottom: 0">forms</li>
                <li style="margin-bottom: 0">forms-ext</li>
                <li style="margin-bottom: 0">mediaelement</li>
                <li style="margin-bottom: 0">track</li>
                <li style="margin-bottom: 0">filereader</li>
                <li style="margin-bottom: 0">details</li>
            </ul>

            <p>
                <tt>setOptions</tt> should always be called before the <tt>polyfill</tt> method.
            </p>

            <p>The available options for <tt>$.webshims.setOptions</tt>:</p>
            <ul>
                <li><strong>extendNative</strong>  Webshims lib will automatically extend DOM-Objects with polyfilled methods and will additionally generate a jQuery plugin with this method name. If extendNative is set to false, webshims lib
                    won't touch any DOM-Objects and will only implement jQuery plugins. Setting this option to false might improve DOM performance. <br>
                    <em>default: false</em>
                </li>
                <li><strong>basePath</strong> The shims folder is computed automatically. If the name of polyfiller.js is changed <strong>and</strong> the polyfill-script is loaded async, this computation can be wrong and you have to set the folder manually. Example:<br>
                    <tt> $.webshims.setOptions('basePath', '/yourFolderTo/shims/'); </tt> <br>
                    <em>default: computed path to shims folder</em>
                </li>
                <li><strong>waitReady</strong> Setting this to true delays jQuery's ready-event until all polyfilled features are ready. This option should be set to false, if webshims lib polyfiller.js is loaded asynchronously. This option can also be set to false, if a website is using only HTML5 markup APIs (pure HTML or $.attr) and
                    doesn't use any DOM-/JS-APIs on DOM-ready. If this feature is set to false, scripted access to polyfilled APIs have to be added inside of a <tt>$.webshims.ready</tt> callback. <br>
                    <em>default: true</em>
                </li>
                <li><strong>disableShivMethods</strong> Automatically disables the <a href="https://github.com/aFarkas/html5shiv">shivMethods</a> option of html5shiv. <br>
                <em> default: true</em>
                </li>
                <li>
                    <strong>debug</strong> Setting to true enables debug info to be printed in the developer console. <br>
                    <em>default: false</em>
                </li>
            </ul>
            <pre>
$.webshims.setOptions('extendNative', false);
</pre> 
            <p>
                <tt>setOptions</tt> can also take a single options parameter:
            </p>
            <pre>
$.webshims.setOptions({
  extendNative: false
});
</pre> 
            <p>
                Feature specific options are nested options with the feature name as their key.
            </p>
            <pre>
$.webshims.setOptions({
  // configure generally option
  extendNative: false,

  // configure canvas-shim
  canvas: {
    type: 'flash' // use flashcanvas instead of excanvas as polyfill
  },

  // configure forms-shim
  forms: { 
    customMessages: true // implement customValidationMessages
  }
});
</pre> 
            <p>The polyfill-options can also be changed by using declarative markup, using a data-polyfill-cfg attribute with a valid JSON string on a script-element:</p>
            <pre>
&lt;script src="some.js" data-polyfill='{
"basePath": "pathToYour/shims-folder/",
"canvas": {
  "type": "flash"
}
}'&gt;

&lt;/script&gt;
</pre>
        </p>


        <p id="Guide-fire-when-ready">
            <b class="header">Fire When Ready</b> 
            <br>

            <p>Not every feature is ready immediately in all browsers; some shims might take time to load before you can use them. You can use one of jQuery's <tt>ready</tt> methods to delay working with elements until the DOM and any necessary shims are
                ready.</p>
            <pre>
$(function(){
  // work with DOM + all implemented features
});

$(document).ready(function(){
  // work with DOM + all features
});
</pre> 


            <p>If you want to use a feature as soon as possible or you have set the <tt>waitReady</tt> option to <tt>false</tt>, you can use <tt>$.webshims.ready</tt> and pass the feature name(s) and a callback function:</p>
            <pre>
$.webshims.ready('geolocation json-storage', function(){
  // work with geolocation, JSON and localStorage
});
</pre> 
            <p>Note that this callback function may be called before the DOM is ready. If you want to use a feature after DOM-Ready, simply pass the string 'DOM':</p>
            <pre>
$.webshims.ready('DOM canvas', function(){
  // work with canvas in the document
});
</pre> 

        </p>

        <p id="Guide-dom-abstractions">
            <b class="header">DOM Abstractions</b> 
            <br>
            
            <p>Due to the fact that we cannot extend accessors of elements in all browsers, we always use jQuery as an extension-wrapper.</p>
                    <ul>
                        <li>
                            <p><strong>Accessing DOM properties/attribute IDLs</strong>: if the feature allows accessing a specific attribute or property, always use jQuery's built-in <tt>$.prop</tt> (in case of IDL attributes/properties) or <tt>$.attr</tt>/<tt>$.removeAttr</tt> (in case of content attributes) method:</p>
<pre>
// instead of accessing a property directly (e.g. this.validity), use $.fn.prop 
$(this).prop('validity');
// or:
//$.prop(this, 'validity');

//setting a property
$('video').prop('currentTime', 200);
// or:
//$.prop(videoElement, 'currentTime', 200);
</pre>
                        </li>
                        <li>
                            <p><strong>calling a DOM method</strong>: While DOM properties have to be accessed through jQuery's <tt>$.prop/$.attr</tt> methods, DOM methods can be accesed using $.prop and executed in the context of the DOM element.</p>
<pre>
// "this" refers to a DOM element, not a jQuery object
var fn = $.prop(this, 'checkValidity');
fn.apply(this);
</pre>
                            <p>To make this more easier Webshims lib also generates a jQuery plugin which wraps the featured method, so you can use jQuery too:</p>
<pre>
$(this).checkValidity();

$(this).callProp('checkValidity'); // $(this).callProp('play');
</pre>
                            <p>The jQuerified method can also take some arguments, if specified by the spec.</p>
                            
<pre>
$('video').addTextTrack('subtitles', 'just a test', 'en');

$('video').callProp('addTextTrack', ['subtitles', 'just a test', 'en']);    
</pre>                         
                            <p>If you pass a list of nodes and the method doesn't return anything, the method will be called on each element in this list, otherwise it will be called on the first element.</p>
                            <p>In case a developer wants to make method calling "feel 100% native", the general option <tt>extendNative</tt> can be set to <tt>true</tt>.</p>
<pre>
$.webshims.setOptions('extendNative', true);
$.webshims.polyfill('forms');
// ...
this.checkValidity()  // or use $(this).callProp('checkValidity')

$('video').get(0).addTextTrack('subtitles', 'just a test', 'en');
</pre> 

                        </li>
                        <li>
                            <p><strong>binding to events</strong>: Always use jQuery's <tt>on</tt>, <tt>bind</tt> method to register your event handlers. <tt>addEventListener</tt> or inline event handler won't work in polyfilled browsers. Most events in the HTML5 specification are so-called simple events. Simple events do not bubble. Due to the fact that developers really like event delegation and jQuery cannot distinguish between the event phases (capturing/propagation), we use event capturing in the native implementation and <tt>$.fn.trigger</tt> in the shim.</p>
                            <p>This means that some HTML5 events go down the DOM tree in capable browsers and go up the tree in polyfilled browsers. This can create differences if you are calling <tt>event.stopPropagation();</tt> or <tt>return false;</tt> in your event handler. If you only want to prevent the default, don't use <tt>return false;</tt>, use <tt>event.preventDefault();</tt> instead.</p>
                        </li>
                        <li>
                            <p><strong>manipulation methods/dynamically adding HTML5 content</strong>: To insert new HTML5 content dynamically, use <tt>.htmlPolyfill()</tt>, <tt>.appendPolyfill()</tt>, <tt>.prependPolyfill()</tt>, <tt>.afterPolyfill()</tt>, <tt>.beforePolyfill()</tt> and <tt>.replaceWithPolyfill()</tt>:</p>
<pre>
// three different examples
$('form').appendPolyfill('&lt;fieldset&gt;&lt;input type="date" /&gt;&lt;/fieldset&gt;');
$('#canvas-box').htmlPolyfill('&lt;canvas&gt;&lt;/canvas&gt;');
$('datalist#list select').prependPolyfill('&lt;option value="new suggestion item" /&gt;');
</pre>
                            <p><small>See also <a href="demos/shiv.html#dynamic">dynamic HTML5 description</a>.</small></p>
                        </li>
                        <li>
                            <p><strong>no shadowdom</strong>: Webshims lib sometimes has to add additional DOM elements to mimic the UI of HTML5 elements. This can sometimes create differences, between polyfilled and non polyfilled browsers. Webshims lib gives you a method called 'getShadowElement' to access the shadowelement from the native element and a method called 'getNativeElement' to access the native element from the shadowelement. If the element has no shadowelement the element itself is returned.</p>
                            
<pre>
// animate the width of all date - inputs to a width of 300
$('input[type="date"]').getShadowElement().animate({width: 300});
</pre>
                            <p>Some styles like float or display: none/block are not initially reflected by the shadowdom, it is a good approach to do this on a wrapper element:</p>
<pre>&lt;!-- instead of --&gt;
&lt;div class="form-field"&gt;
  &lt;label for="date" style="display: none;"&gt;Birthdate&lt;/label&gt;
  &lt;input type="date" id="date" style="display: none;" /&gt;
&lt;/div&gt;
&lt;!-- do this: --&gt;
&lt;div class="form-field" style="display: none;"&gt;
  &lt;label for="date"&gt;Birthdate&lt;/label&gt;
  &lt;input type="date" id="date" /&gt;
&lt;/div&gt;

&lt;!-- or instead of: --&gt;
&lt;div class="mediaplayer"&gt;
  &lt;video src="file.mp4" controls style="margin: 0 10px 5px 0; float: left;"&gt;&lt;/video&gt;
&lt;/div&gt;
&lt;!-- do this: --&gt;
&lt;div class="mediaplayer" style="margin: 0 10px 5px 0; float: left;"&gt;
  &lt;video src="file.mp4" controls&gt;&lt;/video&gt;
&lt;/div&gt;
</pre>
                            <p><strong>re-rendering shadowelements</strong>: On dynamic websites shadowelements dimensions and/or positions sometimes need to be updated, this can be achieved by triggering the <tt>updateshadowdom</tt>.</p>
<pre>
$(document).trigger('updateshadowdom');
</pre>
                            <p><small>The <tt>updateshadowdom</tt> event is automatically and lazily triggered on window.resize/emchange events.</small></p>
                        </li>
                    </ul>
            
        </p>

        <p id="Customizing">
            <b class="header">Customizing Webshim</b> 
        </p>

        <p id="Customizing-modernizr">
            <b class="header">Modernizr</b> 
            <br>
            Webshims lib does not need every Modernizr test and supports creating a <a href="http://modernizr.com/download/#-canvas-audio-video-input-inputtypes-localstorage-sessionstorage-geolocation-shiv-cssclasses-addtest-prefixed-testprop-testallprops-prefixes-domprefixes-elem_track-load">custom Modernizr build</a>.
            (Webshims lib uses <a href="http://requirejs.org/">requireJS</a> or <a href="https://gist.github.com/aFarkas/936413">sssl</a> as a script loader, if this is included, if not it uses Modernizr.load/yepnope.)
        </p>

        <p>
            <small> <a href="http://modernizr.com/download/#-canvas-audio-video-input-inputtypes-localstorage-sessionstorage-geolocation-shiv-cssclasses-addtest-prefixed-testprop-testallprops-prefixes-domprefixes-elem_track-load"> Modernizr detections used by webshim</a> </small>
        </p>


        <p id="Customizing-extending">
            <b class="header">Writing a New Polyfill</b> 
            <br>

            <p>A Pollyfill is always split into at least two parts. First the test and loader definition, and then the implementation.</p>

            <p>Assume there is a new method <tt>magicMethod</tt> on the window object that we want to polyfill if the browser doesn't provide it. An implementation would look like this:</p>
            <pre>
$.webshims.addPolyfill('magicMethod', {
  test: function(){
    return ('magicMethod' in window); 
  }
});
// loads magicMethod.js from shim-folder if test returns false
</pre> 
            <p>Create a file called magicMethod with your polyfill code and place it in the shim folder:</p>
            <pre>
window.magicMethod = function(){
  // your polyfill implementation
};
</pre> 

            <p>If your implementation has dependencies on other polyfills/modules, you can add a dependencies property to make sure they're loaded too:</p>

            <pre>
$.webshims.addPolyfill('magicMethod', {
  test: function(){
    return ('magicMethod' in window); 
  },
  d: ['es5', 'json-storage'] // d = dependencies
});
// load magicMethod.js and its dependencies if test returns false
</pre> 
            <p>If your shim has dependencies, you have to register your implementation code with <tt>$.webshims.register</tt>:</p>
            <pre>
$.webshims.register('magicMethod', function($, webshims, window, document, undefined, options){
  // now you can use es5-feature and json-storage feature  
  window.magicMethod = function(){
    // your polyfill implementation
  };
});
</pre> 

            <p>In case of a DOM extension, webshims lib comes with some useful extension-methods.</p>
            <pre>
$.webshims.addPolyfill('mediaelement', {
  test: function(){
    return ('canPlayType' in document.createElement('video'));  
  },
  d: ['dom-support'],
  methodNames: ['play'] // pause, load
});
// load mediaelement.js and DOM extension features from shim folder
// if test returns false and always create a jQuery plugin called play,
// which tries to invoke native or polyfilled play

// listen to 'play' events in the capturing phase
// can use event delegation with jQuery's bind method
$.webshims.capturingEvents(['play']);
</pre>

            <p>Now put a mediaelement.js inside of your shim folder and start implementing some features. The <tt>dom-support</tt> feature of Webshims lib comes with some very useful implementation helpers. Here are two of them:</p>
            <ul>
                <li><tt>$.webshims.defineNodeNamesProperty</tt> (nodeNames, property, descriptor)</li>
                <li><tt>$.webshims.defineNodeNamesBooleanProperty</tt> (nodeNames, property, descriptor)</li>
            </ul>
            <pre>
// wait till the DOM-Extension feature is loaded
$.webshims.register('mediaelement', function($, webshims, window, document, undefined, options){
  // webshims refers to jQuery.webshims in this function
  
  // Implements a new IDL property on audio, video called currentTime
  webshims.defineNodeNamesProperty('audio, video', 'currentTime', {
    prop: {
      get: function(){
        // your getter implementation ("this" refers to the element)
      },
      set: function(value){
        // your setter implementation ("this" refers to the element)
      }
    }
  });
  
  // Implements a new constant property called HAVE_CURRENT_DATA on audio, video
  webshims.defineNodenamesProperty('audio, video', 'HAVE_CURRENT_DATA', {
    prop: {
      value: 2
    }
  });
  
  // Implements a new method called play on audio, video
  webshims.defineNodeNamesProperty('audio, video', 'play', {
    prop: {
      value: function(){
        // your play method implementation
        // this refers to the element
      }
    }
  });
  
  
  
  // Implements a new boolean IDL property called controls on audio, video
  // which is reflected by a content attribute
  webshims.defineNodeNamesBooleanProperty('audio, video', 'controls', {
    // set works more like an onSet:
    // you don't have to set the value anymore on the DOM node, only handle true/false values
    set: function(value){
      if(value){
        // show controls for elem
      } else {
        // hide controls for elem
      }
    },
    initAttr: true
  });
}); 
</pre>

        </p>

    </div>

    <!--  <script src="docs/js/jquery.lazyload.js"></script>  -->

    <script>
        // Set up the 'play' buttons for each runnable code example.
        $(function () {
            $('.runnable').each(function () {
                var code = this;
                var button = '<div class="run" title="Run"></div>';
                $(button).insertBefore(code).bind('click', function () {
                    eval($(code).text());
                });
            });

            //$('[data-original]').lazyload();
        });
    </script>

</body>

</html>
